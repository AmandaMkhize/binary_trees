Binary Trees Project
Introduction
Welcome to my Binary Trees Project! Through this project, I've deepened my understanding of binary trees and related concepts. By the end of this project, I have learned the following topics and can confidently explain them to anyone, without needing to consult Google.

Learning Objectives
I learned that a binary tree is a data structure in which each node has at most two children, referred to as the left child and the right child. This hierarchical structure is used in various applications, including expression parsing, binary search trees, and more.

I also learned the difference between a binary tree and a Binary Search Tree (BST). While a binary tree is a general structure where each node can have up to two children, a BST is a specific type of binary tree where each node follows the order property: the left subtree contains only nodes with values less than the node's value, and the right subtree contains only nodes with values greater than the node's value. This property makes BSTs efficient for search operations.

In terms of time complexity, I learned that binary trees, especially balanced ones, can offer significant advantages over linked lists. For example, searching, inserting, and deleting elements in a balanced binary search tree can be done in O(log n) time, whereas in a linked list, these operations require O(n) time.

I also gained an understanding of the depth, height, and size of a binary tree. The depth of a node is the number of edges from the node to the tree's root node. The height of a node is the number of edges on the longest path from the node to a leaf. The size of a binary tree is the total number of nodes it contains.

Moreover, I learned about the different traversal methods to go through a binary tree. These include in-order traversal, pre-order traversal, post-order traversal, and level-order traversal. Each method serves different purposes and can be used to solve various types of problems.

Lastly, I learned about the different types of binary trees: a complete binary tree, where all levels are fully filled except possibly the last, which is filled from left to right; a full binary tree, where every node has either 0 or 2 children; a perfect binary tree, where all internal nodes have two children and all leaves are at the same level; and a balanced binary tree, where the height difference between the left and right subtrees of any node is at most one.

Through this project, I've developed a comprehensive understanding of binary trees and their applications, and I'm excited to apply this knowledge in future projects.
